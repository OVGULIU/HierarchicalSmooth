!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AnalyzeLaplacian	HierarchicalSmooth.cpp	/^std::tuple< SpMat, SpMat > HSmoothMain::AnalyzeLaplacian( SpMat& GL ) {	\/\/ NOTE: GL should be column-major$/;"	f	class:HSmoothMain
EdgeCount	Triangulation.h	/^	EdgeCount( int x, int y ) {$/;"	f	struct:EdgeCount
EdgeCount	Triangulation.h	/^struct EdgeCount {$/;"	s
FastChainLinkSort	Triangulation.cpp	/^EdgeList HSmoothTri::Triangulation::FastChainLinkSort( EdgeList& inList ) {$/;"	f	class:HSmoothTri::Triangulation
GetDirichletBVP	HierarchicalSmooth.cpp	/^std::tuple< SpMat, SpMat > HSmoothMain::GetDirichletBVP( SpMat& GL, SpMat& yIn, matindex& nFixed, matindex& nMobile ) {$/;"	f	class:HSmoothMain
GetEdges	Triangulation.cpp	/^std::tuple< EdgeList, EdgeList > HSmoothTri::Triangulation::GetEdges( trimesh& inTri ) {$/;"	f	class:HSmoothTri::Triangulation
GetObjFn	HierarchicalSmooth.cpp	/^double HSmoothMain::GetObjFn( Smoother& smth, double feps, $/;"	f	class:HSmoothMain
GetSmoothed	VolumeSolver.h	/^		meshnode GetSmoothed( void ) { return vsNodeSmooth; }$/;"	f	class:VolumeSolver::VolumeSolver
GraphLaplacian	HierarchicalSmooth.cpp	/^std::tuple< SpMat, std::vector< int> > HSmoothMain::GraphLaplacian( trimesh& tri ) { $/;"	f	class:HSmoothMain
GraphLaplacian	Triangulation.cpp	/^std::tuple< SpMat, matindex > HSmoothTri::Triangulation::GraphLaplacian( void ) {$/;"	f	class:HSmoothTri::Triangulation
HSmoothBase	Base.h	/^namespace HSmoothBase{ $/;"	n
HSmoothMain	HierarchicalSmooth.h	/^namespace HSmoothMain{ $/;"	n
HSmoothTri	Triangulation.h	/^namespace HSmoothTri {$/;"	n
HierarchicalSmooth	VolumeSolver.cpp	/^meshnode VolumeSolver::VolumeSolver::HierarchicalSmooth( bool logging, std::string logfile ) {$/;"	f	class:VolumeSolver::VolumeSolver
Laplacian2D	HierarchicalSmooth.cpp	/^SpMat HSmoothMain::Laplacian2D( int N, std::string type ) {$/;"	f	class:HSmoothMain
MarkSectionAsComplete	VolumeSolver.cpp	/^void VolumeSolver::VolumeSolver::MarkSectionAsComplete( matindex& idx ) {$/;"	f	class:VolumeSolver::VolumeSolver
MaxIterations	VolumeSolver.h	/^		int MaxIterations;$/;"	m	class:VolumeSolver::VolumeSolver
Mesh	Triangulation.h	/^		trimesh Mesh, nSubTri;				\/\/ the Delaunay triangulation from which everything is derived$/;"	m	class:HSmoothTri::Triangulation
MyDict	Triangulation.h	/^		DictBase< EdgeCount >::EdgeDict MyDict;$/;"	m	class:HSmoothTri::Triangulation
SliceMesh	VolumeSolver.cpp	/^trimesh VolumeSolver::VolumeSolver::SliceMesh( std::vector< int >& FromThesePatches ) {$/;"	f	class:VolumeSolver::VolumeSolver
Smooth	HierarchicalSmooth.cpp	/^meshnode HSmoothMain::Smooth( meshnode& NodesIn, matindex& nFixed, SpMat& GL, double fThresh, int nIter ) {$/;"	f	class:HSmoothMain
Smooth	HierarchicalSmooth.cpp	/^meshnode HSmoothMain::Smooth( meshnode& NodesIn, std::string type, double fThresh, int nIter ) {$/;"	f	class:HSmoothMain
Status	VolumeSolver.h	/^		is_smoothed Status;$/;"	m	class:VolumeSolver::VolumeSolver
Triangulation	Triangulation.cpp	/^HSmoothTri::Triangulation::Triangulation( trimesh& inTri ) {$/;"	f	class:HSmoothTri::Triangulation
Triangulation	Triangulation.h	/^	class Triangulation {$/;"	c	namespace:HSmoothTri
VolumeSolver	VolumeSolver.cpp	/^VolumeSolver::VolumeSolver::VolumeSolver( $/;"	f	class:VolumeSolver::VolumeSolver
VolumeSolver	VolumeSolver.h	/^	class VolumeSolver {$/;"	c	namespace:VolumeSolver
VolumeSolver	VolumeSolver.h	/^namespace VolumeSolver {$/;"	n
_HSMOOTH_BASE	Base.h	8;"	d
_HSMOOTH_HSMOOTH	HierarchicalSmooth.h	9;"	d
_HSMOOTH_TRI	Triangulation.h	13;"	d
_HSMOOTH_VOLSOLVER	VolumeSolver.h	9;"	d
allEdges	Triangulation.cpp	/^EdgeList HSmoothTri::Triangulation::allEdges( void ) {$/;"	f	class:HSmoothTri::Triangulation
connectivityList	Triangulation.cpp	/^trimesh HSmoothTri::Triangulation::connectivityList( void ) {$/;"	f	class:HSmoothTri::Triangulation
differentiateFaces	Triangulation.cpp	/^void HSmoothTri::Triangulation::differentiateFaces( void ) {$/;"	f	class:HSmoothTri::Triangulation
edge_list	Triangulation.h	/^		EdgeList edge_list, free_boundary, free_boundary_segments;$/;"	m	class:HSmoothTri::Triangulation
fDiagCount	Triangulation.h	/^		std::vector< double > fDiagCount;$/;"	m	class:HSmoothTri::Triangulation
fError	VolumeSolver.h	/^		double fError, fErrorThreshold;$/;"	m	class:VolumeSolver::VolumeSolver
fErrorThreshold	VolumeSolver.h	/^		double fError, fErrorThreshold;$/;"	m	class:VolumeSolver::VolumeSolver
fout	VolumeSolver.h	/^		std::ofstream fout;	\/\/ log file handle$/;"	m	class:VolumeSolver::VolumeSolver
freeBoundary	Triangulation.cpp	/^std::tuple< EdgeList, EdgeList > HSmoothTri::Triangulation::freeBoundary( void ) {$/;"	f	class:HSmoothTri::Triangulation
free_boundary	Triangulation.h	/^		EdgeList edge_list, free_boundary, free_boundary_segments;$/;"	m	class:HSmoothTri::Triangulation
free_boundary_segments	Triangulation.h	/^		EdgeList edge_list, free_boundary, free_boundary_segments;$/;"	m	class:HSmoothTri::Triangulation
getcomplement	Base.cpp	/^matindex HSmoothBase::getcomplement( matindex& nSet, int N ) {$/;"	f	class:HSmoothBase
getindex	Base.cpp	/^matindex HSmoothBase::getindex( std::vector< int >& FromThis ) {$/;"	f	class:HSmoothBase
getindex	Base.cpp	/^matindex HSmoothBase::getindex( std::vector< int >& FromThis, matindex& InThis ) {$/;"	f	class:HSmoothBase
ismember	Base.cpp	/^trimesh HSmoothBase::ismember( trimesh& Array1, std::vector<int>& Array2 ) {$/;"	f	class:HSmoothBase
matunion	Base.cpp	/^matindex HSmoothBase::matunion( matindex& mat1,  matindex& mat2 ) {$/;"	f	class:HSmoothBase
merge	Base.cpp	/^void HSmoothBase::merge( SpMat& Source, SpMat& Target, matindex& Locations ) {$/;"	f	class:HSmoothBase
merge	Base.cpp	/^void HSmoothBase::merge( meshnode& Source, meshnode& Target, matindex& Locations ) {$/;"	f	class:HSmoothBase
nSubTri	Triangulation.h	/^		trimesh Mesh, nSubTri;				\/\/ the Delaunay triangulation from which everything is derived$/;"	m	class:HSmoothTri::Triangulation
nUnique	Triangulation.h	/^		std::vector< int > nUnique;$/;"	m	class:HSmoothTri::Triangulation
ncount	Triangulation.h	/^	int ncount;$/;"	m	struct:EdgeCount
one	VolumeSolver.h	/^		matindex one, three;$/;"	m	class:VolumeSolver::VolumeSolver
orig_pair	Triangulation.h	/^	EdgePair orig_pair;$/;"	m	struct:EdgeCount
three	VolumeSolver.h	/^		matindex one, three;$/;"	m	class:VolumeSolver::VolumeSolver
vsBoundaryDict	VolumeSolver.h	/^		DictBase< std::vector< int > >::EdgeDict vsBoundaryDict;$/;"	m	class:VolumeSolver::VolumeSolver
vsLabel	VolumeSolver.h	/^		facelabel vsLabel;$/;"	m	class:VolumeSolver::VolumeSolver
vsMesh	VolumeSolver.h	/^		trimesh vsMesh;$/;"	m	class:VolumeSolver::VolumeSolver
vsNode	VolumeSolver.h	/^		meshnode vsNode, vsNodeSmooth;$/;"	m	class:VolumeSolver::VolumeSolver
vsNodeSmooth	VolumeSolver.h	/^		meshnode vsNode, vsNodeSmooth;$/;"	m	class:VolumeSolver::VolumeSolver
vsType	VolumeSolver.h	/^		nodetype vsType;$/;"	m	class:VolumeSolver::VolumeSolver
