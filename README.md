# Hierarchical Smoothing
![alt tag](https://github.com/siddharth-mv/HierarchicalSmooth/blob/master/Banner.png?raw=true "Triple line fidelity with hierarchical smoothing")

## Description
Thie repo contains multiple implementations of the hierarchical smoothing algorithm applicable to voxelated meshes of interface networks. Primarily directed at users of microstructure analysis software, specifically [DREAM.3D](http://dream3d.bluequartz.net/). 

## Motivation
1. Faithfulness to mesoscopically smooth interfaces
1. Minimum user interference in deciding numerical parameters
1. Automatability over an entire volume
1. Proper treatment of GB interiors, triple lines and quad points

A detailed description of the mathematical theory is given [here](http://dx.doi.org/10.1016/j.commatsci.2016.08.021).

## Software requirements

### Import/Export of data from HDF5
1. DREAM.3D v6.2 or higher (to import and export ASCII data)	__OR__
1. [HDFView](https://www.hdfgroup.org/products/java/hdfview/) to export from existing DREAM.3D data file

### Matlab
1. Matlab R2013a or higher (extensive use of the `triangulation` object)

### Python
1. NumPy (>=1.11.2)
1. SciPy (>=0.18.1)

## Tutorials
 These tutorials does not cover the import and export of the required microstructure data relative to DREAM.3D. Included is a sample data set (in the `examples/ex2` directory) containing the mesh of a 794-grain microstructure volume. The following steps illustrate the form of the input and implementation of the central `HierarchicalSmooth` routine. In each tutorial, the working directory is assumed to be that which contains the corresponding source code.
 
 [Matlab tutorial](#matlab-usage)

 [Python tutorial](#python-usage)

### Matlab usage
* The input array `xDat` contains a set of N points in 3D in the form of a 3xN array. These represent voxelated sample points of the GB network.
```Matlab
xdat = load( '../../examples/ex2/SharedVertexList.txt' );
xdat = xdat';
```
* The input array `tri` contains the Delaunay triangulation of the points in `xDat` in the form of an Mx3 integer array. A +1 offset is applied in order to accommodate the difference between DREAM.3D's 0-indexing and Matlab's 1-indexing.
```Matlab
tri = 1 + load( '../../examples/ex2/SharedTriList.txt' );
```

* The Quick Surface mesh filter in DREAM.3D assigns a unique integer ID to every grain in the volume. The following input array serves to identify the grain boundary that a particular triangular element of array `tri` belongs to, in the form of an Mx2 integer array. The integers in each row denote the grains on either side of that particular triangular patch of grain boundary. 
```Matlab
fl = load( '../../examples/ex2/FaceLabels.txt' );
```

* By default DREAM3D assigns the 'grain ID' of -1 to the top and bottom surfaces of the imaged volumes, and 0 to the sides respectively. These buffer regions are included in the array `fl` as well, for example the row [ 30, -1 ] in `fl` denotes the 'grain boundary' between the grain 30 and the top/bottom surface of the volume. These are unnecessary inputs to the smoothing routine and need to be filtered out to save time.
```Matlab
f = find( any( fl==-1 | fl==0, 2 ) );
fl( f, : ) = [];
tri( f, : ) = [];
```

* The final required input is the classification of the surface mesh nodes as belonging to surface interiors, triple lines or quad points. 
```Matlab
ntype = load( '../../examples/ex2/NodeType.txt' );
ntype = ntype';
```

* The next line runs the smoothing routine with these arrays as input. This could take a long time even for a few hundreds of grains; the Matlab code is not optimized for speed. The log file generated by default is `Smooth.Default.log` and can be monitored in real time. 
```Matlab
xsmooth = HierarchicalSmooth( xdat, tri, fl, ntype );
```
Optional arguments for `HierarchicalSmooth` are described in the script file. Finally, the script `Test.m` plots a comparison between the smoothed and unsmoothed versions of a grain of the user's choice. 

### Python usage
The Python functions were written to mirror the corresponding functions in the Matlab source code as much as possible. Specifically, the primary function `HierarchicalSmooth` and its auxiliary functions are written in a file `HierarchicalSmooth.py` which is loaded as a module. A bare-bones version of Matlab's indispensible `ismember` function is implemented in `Base.py`. Further, the basic functionality of Matlab's `triangulation` object is implemented in `Triangulation.py`. The following steps are the essence of the test script `Src/Python/TestSuite/SmoothVolume.py`. 

* First the required namespaces are loaded:
```Python
import numpy as np
import HierarchicalSmooth as hs
```

* The relative path of the input data files is stored in a string:
```Python
filePrefix = '../../examples/ex2'
```

* The following input arrays are loaded and cast into the appropriate types and dimensions:
  *  Sample vertices as a $3 \times N$ array of floats:
  ```Python
  P = np.loadtxt( filePrefix + '/SharedVertexList.txt', dtype=float ).T
  ```

  *	Mesh triangulation as a $M \times 3$ integer array. Note that unlike for Matlab, there's no need to account for the zero offset.
  ```Python
  tri = np.loadtxt( filePrefix + '/SharedTriList.txt', dtype=int )
  ```

  * $M \times 2$ integer array indicating the ID of the grain on either side of each triangular patch. Note that the direction in going from grain 1 to grain 2 corresponds to the right-handed winding sequence of the points of the mesh element. This is the default behavior of Dream.3d and is critical in obtaining the connectivity of the free boundary nodes of each interface.
  ```Python
  nFaces = np.loadtxt( filePrefix + '/FaceLabels.txt', dtype=int )
  ```

  * An integer array of length $N$ denoting the type of each node in the array `P`. According to Dream.3d convention, values of 2, 3 and 4 correspond respectively to interior sample points, triple junctions and quad points in the volume interior, and 12, 13, 14 corresponds to the same topological features on the volume edges.
  ```Python
  nType = np.loadtxt( filePrefix + '/NodeType.txt', dtype=int )
  ```

* Finally, the smoothing is achieved by running the command:
```Python
PS, bPS = hs.HierarchicalSmooth(
	xPoints=P, tri=tri,
	nFaceLabels=nFaces,
	nNodeType=nType
)
```
Note that this does not ignore the surfaces on the exterior of the volume. 

* Owing to extensive use of dictionary lookups, the Python code is faster by far than the Maltab code. Performance varies with system specifics; the 794 grains in the `examples/ex2` data set were smoothed in about 1.5 hours on a laptop running Ubuntu 16.04 with 4GB RAM and a dual core hyper-threaded 2.40 GHz Intel i3 CPU

* There are optional arguments to `HierarchicalSmooth` that deal with the internal interval bisection threshold and the maximum number of iterations, as well as the text log file to which to redirect `sys.stdout` if needed.

## Acknowledgements
1. Anthony Rollett (Dept of MSE, CMU)
2. David Menasche (Dept of Physics, CMU)


